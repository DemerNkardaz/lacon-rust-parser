/// Язык LaCoN исполняется на Rust
[Mode:Data] /// Режим по умолчанию, [Mode:Programm] для режима работы «как другие ЯП»

/// Имена могут быть на любом языке, содержать «_», «-» и даже цифры (кроме начала названия)
$let variable value <any>        /// обычная переменная (mutable)
$const constant value <any>      /// обычная константа (immutable)
$let &varRef value <any>         /// mutable ссылка (varRef)
$const &constRef value <any>     /// immutable ссылка (constRef)
container value <any>          /// «контейнер» или «свободная переменная», именно она представляет выходные данные в режиме данных, не может быть константой или использовать varRef, в коре документа образуют элементы первого уровня, т.е. прямое объявление:

key-1 value
key-2 value

/// Равно выходным данным:

{
	key-1 value
	key-2 value
}


static variable || constant
local variable || constant /// Явное указание на локальность элемента к текущему блока кода и вложенным блокам кода
global variable || constant /// Явное указание на глобальность элемента
/// local и global могут быть использованы в логике функций при «выборе» элемента, например если есть одноимённые переменные как в глобальной, так и в локальной видимости:
private ...
public ...

static $const &constRef value <any>

$let num 1
@function name(){
	local $num 2
	@if (local $num === 2) {
		global $num local $num /// Присвоили глобальной переменной значение локальной
	}
}

@import path /// Импортирует обработанные данные из файла со взаимной глобальной видимостью, может использовать деконструкцию @import... path), может быть вставлен в любом месте данных и импорт произойдёт именно туда
@export value <any> /// Если задано в импортируемом файле — импортируется содержимое @export, в противном случае импортируются данные из всего файла
@module path /// Включает логику из файла со взаимной глобальной видимостью
@module path as namespace
@module { ... } path
@module { ... } path as namespace

@return || @break N || @continue N || @throw || @try-@catch-@finally {} /// N по умолчанию 1, но явное указание позволяет повлиять на высшестоящие блоки
@cancel N /// Прерывает исполнение логики текущего блока
@exit /// Тоже самое, но для всей выполняемой функции/процедуры

&& as AND
|| as OR
! as NOT
== as Soft Equal
=== as Hard Equal
~= as Shorthand for RegExp: @if($val ~= "expr"){...}

@if(){} @elif(){} @else{}

@if !(5 > 8) {
	@return something...
}

@if (!("word" === "WORD") && ("word" == "WORD")) { /// ИСТИНА
	@retun true
}
/// Альтрантивная запись:
@if ("word" !== "WORD" && "word" == "WORD") { /// ИСТИНА
	@retun true
}

@for(){}
@for() in @pairs(){}
@for() in @range(){}

@loop value<int> {}

@while(){}
@do {} @while()

@switch(){@case || @default}

@match(){}

@match($value) {
    (x<int>, y<int>) => @return x + y       /// кортеж
    [first, second, ...rest] => @return first /// массив
    {key1: v1, key2: v2} => @return v1 + v2  /// словарь
    _ => @return none
}
@match($data) {
    {user: {name: n<string>, age: a<int>}, active: true} => @return n
    _ => @return "Unknown"
}
@match($data) {
    {user: u@{name: n, age: a}} => @return n
    _ => @return "Unknown"
}
@match($val) {
    x<int> @if (x > 0) => "Positive"
    x<int> @if (x < 0) => "Negative"
}
@match($text) {
    s<string> ~= "pattern" => @return true
    _ => @return false
}

@function name(args){}
@procedure name(args){} /// Не может вернуть значение


/// Пример
@function calc(a<float>, b<float>, c<operator> +):<float> { /// «+» оператор по умолчанию
	$const d<float> $a $c $b
	@return $d
} /// Использована строгая типизация входных и выходных данных
/// Альтернативные способы объявления функций/процедур. @function name нельзя переобъявить, но с $name @function — можно, а #calc @function — константа, изменить её нельзя, но ошибка будет уже связана с константной, а не переобъявлением функции.
$let calc @function(...)
$const calc @function(...)

@function multiple-output(title<string>, condition<dictionary>{a<int> 1, b<int> 4, c<operator> +}):<(description<string>, result<int>)> {
	$const result<int> $condition.a $condition.c $condition.b /// 5 По умолчанию (1 + 4)
	@return ("$title is #result", $result)
}
@function divide($a, $b):<(quotient<int>, remainder<int>)> { ... }
$const (q,r) @divide(10, 3)

/// Функции и процедуры можно использовать как аргументы:

@procedure name1() { @print("test") }
@function name2(arg) {
	@if ($arg is routine) { /// «is» позволяет узнать тип напрямую
		@return $arg() /// ретёрн не обязателен
	}
}
@name2(@name1)

/// Функции имюет .bind(args...) — позволяет закрепить за функций аргументы и вызвать позже:
$funcName @name2.bind(@name1) /// Сделали бинд
$funcName() /// Вызвали функцию с уже заранее объявленным аргументом

$let d none /// <any>
@procedure calc($a<float>, $b<float>, $c<operator> +) {
	global $d = $a $c $b /// Указание global не обязательно, так как у нас нет конфликта с локальными переменными \\\ Знак «=» использован для читаемости, но он не обязателен
}

@function(){...}() OR @() ... /// Анониминая функция, () после {} — самовызов
$let sum @(a,b) a + b
@procedure(){...}() /// Анониминая процедура

() => ... /// Стрелочный синтаксис

/// Функции, процедуры можно объявлять в любой части кода, в то время как переменные, константы и «прямые данные» чувствительно к относительному расположению (до-после чего-либо)
/// Функции и процедуры поддерживают неограниченные аргументы через (args...) — итогом будет массив аргументов

$const constantAplusBequalsD @calc(5, 5) /// 10.0
$const constantAminusBequalsD<int> @int(@calc(5, 5, -)) /// 0 \\\ мы установили тип Integer, однако избежали ошибки, преобразовав number float в number integer


/// Математичекские операции
1 + 1 - 1 / 1 * 1 % 1 ** 1 // 1
1 < 1 > 1 <= 1 >= 1
/// val + -val преобразуется в val - val


/// Типа значений:
prototype /// Родительский, корневой «узел» для всех типов (но не только, так же он родитель для entities, environment, concepts etc.)
	enum enum
	primitive /// Номинальный тип, его не существует, это лишь указание на то, чем являются указанные внутри типы
		undefined undefined /// Не существует
		auto auto /// Автоматическое значение, интерпретируется конечной логикой
		none none /// Значения нет
		nil nil /// Пустое значение
		boolean true || false // (или 1 || 0)
		string "text" OR 'text' OR text (without quotes) /// Строка без кавычек допустима только в объявлении или присвоении, в сравнениях (if elif...) обязательно "" или ''
		operator + - * // / % /// Содержит отдельный оператор, примняемый в математических операциях
		color color /// цвет
		number /// Родительский тип для всех чисел
			int 10
			float 10.0
			hex 0x10
	formal /// «Формальные» типы данных для удобства работы с некоторыми единицами \\\ Могут участвовать в математических операциях: (10em) + 5 = 15em, 5 - 50% = 2.5, берётся тип первого операнда, и например нельзя вычислить em из других формальных данных, но можно наоборот: 16pt + 10em = 136pt (примерно), но 10em + 16pt = ошибка.
		percent 10%
		length 10cm /// nm μm mm cm dm m cm km Mm / ft in mi | pt pc px | em rem
		frequency 10Hz /// kHz MHz GHz THz
		degree 10deg
		radians 10rad
		fraction 10fr
		size 10Kb /// b B KB Mb MB Gb GB Tb TB ...
		time 10s /// ns µs ms s m h w m y \\\ воизбежание конфликта с метров следует явно указать тип
		speed 10km/h /// m/s m/h km/s mph etc.
	object /// Родительских тип для всех объектов
		array [items...] /// Многоуровневый массив
		dictionary {keys values...} /// Может использовать {}, а может полагаться лишь на отступы, как в примере с «number»
		/// array и dictionary не сортируют своё содержимое по умолчанию
		table table /// Двумерный объект
		class {} /// Объект класса, может содержать свои объявления переменных, функций, использует super, this, могут быть вложенные классы
		multilineString ("",""...) / ('',''...) OR @(RAW TEXT)
		routine /// Родительский тип для callable объектов
		/// Модификаторы: @async, @pure, @effect, @inline, @unsafe, @const  ← orthogonal
			function function(args...) /// Функция, возвращает значение и имеет дочерние типы
				/// Алиасы/Traits:
				iterator iterator(args...) /// Возвращает элементы по одному через явный next()
				stream stream(args...) /// Производит последовательность значений до исчерпания или остановки
				predicate predicate(args...) /// Возвращает логическое значение, используется в условиях
				transform transform(args...) /// Преобразует входные данные в выходные без управления потоком
				thunk thunk() /// Отложенное вычисление, исполняемое по требованию
			procedure procedure(args...) /// Процедура, не возвращает значение и возврат значения в принципе запрещён
				/// Алиасы/Traits:
				action action(args...) /// Выполняет действие как атомарную операцию
			generator generator(args...) /// Порождает поток значений (yield), приостанавливая и возобновляя выполнение
			coroutine coroutine(args...) /// Приостанавливаемая routine с двусторонней передачей управления
		math 1 + 2 * 5 /// Отдельный тип для математических выражений, хранить данные о выражении \\\ Работает как с number, так и с formal типами данных

/// Любые примитивные и формальные типы данных при попадании в строку автоматически преобразуются в строку, не вызывая ошибку, если не был явно указан тип <string> у строки, в которую те попадают. Вместе объектов в строку попадает указание на их тип.

/// По умолчанию строки имеют интерполяцию переменных/констант, но можно использовать «\» для экранирования — $var → \$var = обычный текст «$var»

/// Доступ к данным в словаре происходит через структуру key.key.key / key["key"]["key"]
/// Синтаксис key > key > key — навигационный-декларативный, позволяет устанавливать значения и при этом автоматических создаёт несуществующие узлы
key > key > key sub-key=value
key > key(key-1={child-1 sub-key-1=value} key-2={child-2 sub-key-2=value}) > key-3 > child-3 sub-key-3=value
/// Пример с типизацией
key<dictionary> > key<dictionary>(key-1<dictionary>={child-1<dictionary> sub-key-1<any>=value} key-2<dictionary>={child-2<dictionary> sub-key-2<any>=value}) > key-3<dictionary> > child-3<dictionary> sub-key-3<any>=value

/// Массивы, Словари и Многострочные строки подлежат деконструкции через ...value:
first-array [one, two]
second-array [three, four]
index-array [...first-array, ...second-array]

/// В массивы можно добавлять элементы через «+»
array [Item-1]
array + Item-2

/// Тоже и с многострочными текстами
multiline-string ("Line 1")
multiline-string + "Line 2"

multiline-string @(Line 1)
multiline-string + Line 2


/// Значение присваивается либо через пробел, либо через знак «=» (последнее актуально для сокращённого синтаксиса, где с пробелом парсинг будет невозможен)

/// Опциональная типизаация, можно явно задать тип ожидаемого значения и если он не соответствует — ошибка (при этом nil, none и auto могут быть установлены не зависимо от типа, если после объявления типа стоит «?»):

thousand<int>? none
thousand @int(1000) OR 1000 OR @int("1000") /// OK
thousand "1000" /// ERROR
thousand nil /// OK

$let variable-dictionary<dictionary> {
	key [] /// Для дочерних элементов переменной или константы не требуется ключ «$»
}
variable-dictionary [item, item] /// Ошибка, переменная была объявлена с типом «Словарь», но получен массив.
variable-dictionary["key-2"] value /// Ошибка, ключ «key-2» undefined, невозможно присвоить значение
variable-dictionary.key-2 value /// Ошибка, ключ «key-2» undefined, невозможно присвоить значение
variable-dictionary > key-2 value /// Нет ошибки, ключ-значение созданы

/// Символ «?» позволяет узнать существование ключей при попытке обратиться и не упасть с ошибкой undefined если ключа нет
@if($var?.key?.key? === true) {...}


/// Особые синтаксические конструкции
[key, key2] value || [value, value2] /// Массив ключей — позволяет указать множествам ключей одно значение, или если значение массив — каждый ключ получит значение в соответствии с индексом в обоих массивах
[prefix-*key-1*-postfix, key-2] value /// Множествам ключе через «*» можно указать префикс или постфикс (может быть пуст), результат примера:
prefix-key-1-postfix value
prefix-key-2-postfix value

/// Примеры разных форм объявления значения
key none /// Валиден только в блочном синтаксисе и в аргументах
key = none
key=none


/// @return может возвращать данные прямо на место, где был вызов функции:
dict {
	...@someFunction(args...) /// Это сработает при условии, если функция вернула словарь, в противном случае будет ошибка, так как ожидлась ключи-значения, или если результат не объект и не поддерживает деконструкцию — будет сначала соответствующая ошибка, а потом уже ошибка об ожидании ключей-значений
	key value
}

/// Объект можно сделать иммутабельным, «рид-онли»:
dict<dictionary> <immut>{
	key value
}
/// Так это выглядит со стороны синтаксис присвоения более очевидно:
dict<dictionary>=<immut>{
	key value
}

$let arr<array> <immut>[Item]
$const mls<multilineString> <immut>() /// Константа гарантирует, что обычная строка не измениться, но многострочный текст как отдельный объект мутабелен как и другие объекты даже будучи константой

/// Сокращённые операторы присвоения
number 0
number++ /// number === 1
number-- /// number === 0
number += 1 /// number === 1
number -= 1 /// number === 0
/// Теже операторы работают и с formal данными

string . value

/// Отлияи класса от словаря
/// Словарь содержит пары ключ-значение:
$let dictionary {
	key value
	key value
	key value
	key @function(args) { ... }
	/// Словари могут использовать this, это будет обозначать корень объявленного объекта и даже ссылаться на ранее объявленные ключ-значения без необходимости прерывать объявление и отдельно объявлять ключ-значение, ссылающийся на другой ключ-значение того же словаря. this в принципе базовый элемент любого объекта, может быть использован даже массимом, например [item 1, this[1]] → [item 1, item 1]
}
/// В то время как класс сложнее и имее больше возможностей
@class ClassName {
	static $const &constRef value <any> /// Живёт в объявлении класса
	$let state none /// Живёт в экземпляре класса
	
	static @__init(args...) { ... } /// Инициализаця класса
	@__init(args...) { ... } /// Инициализаця экземпляра класса

	static @function methodName(args...) { ... } /// Объявление метода-функции класса
	static @procedure methodName(args...) { ... } /// Объявление метода-процедуры класса
	@function methodName(args...) { ... } /// Объявление метода-функции экземпляра класса
	@procedure methodName(args...) { ... } /// Объявление метода-процедуры экземпляра класса
	private @procedure methodName(args...) { ... } /// Объявление приватного метода-процедуры экземпляра класса

	@class ClassName { ... } /// Nested-класс, может использовать super для ссылки на родительский класс, использовать множество super.super.super в зависимости от вложенности классов

	/// this живёт в контексте — для static this = классу, для экземпляра класса this равен экземпляру класса
}



/// Конечный результат — документ данных или обычное поведения ЯП (в зависимости от режима).

/// Комментарии /// или /* block */

/// Если корень документа данных должен быть определённого типа (по умолчанию это словарь), документ данных можно явно объявить в начале файла или перед началом «прямых данных»:
[Document:Array]

/// Разные функции
@print(output<string>)
@regExp(value<string>, pattern, &varRefMatchObject)
@eval()
@math(expr<math>)() → в данном случае @math сразу возвращает результат выражения
@type(value):<string> → возвращает строку имен итипа

/// Имена не могут иметь зарезервированные значения, т.е. нельзя создать переменную «static = value», потому что static зарезервирован и используется

/// Перед исполнением весь скрипт и его модули/импорты проверяются на соответствие типов (статический анализ типов) (если всё есть <any>, то тогда ошибок именно типов не будет, т.к. динамичесикая типизация (по умолчанию, если не объявлять тип чего-либо))