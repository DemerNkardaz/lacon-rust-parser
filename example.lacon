[Mode:Data][Document:Dictionary]

iterator operators(operatorsArray<Array<Operator>> [+, -, *, **, /, //]):<Operator> {
	const items<Array<Operator>> operatorsArray
	return iterate(items, array)
}

function stagedMath(numbers<Array> [], operatorSymbol<Operator> +):<Number> {
	const result numbers[1] operatorSymbol numbers[2]
	return result
}

const opsIter = operators()
const bindedMath stagedMath.bind([1, 7], opsIter)


maths {
	"1 + 7" bindedMath()   /|\ 1 + 7 = 8
	"1 - 7" bindedMath()   /|\ 1 - 7 = -6
	"1 * 7" bindedMath()   /|\ 1 * 7 = 7
	"1 ** 7" bindedMath()  /|\ 1 ** 7 = 1
	"1 / 7" bindedMath()   /|\ 1 / 7 ≈ 0.142857
	"1 // 7" bindedMath()  /|\ 1 // 7 = 0  (целочисленное деление)
}

print(maths["1 + 7"])   /|\ 8
print(maths["1 - 7"])   /|\ -6
print(maths["1 * 7"])   /|\ 7
print(maths["1 ** 7"])  /|\ 1
print(maths["1 / 7"])   /|\ ≈0.142857
print(maths["1 // 7"])  /|\ 0

generate (0 .. 7) as local let i {
	local const hex-value = format("{:04X}", $i)
	yield domino_n_tile_00_0${i}_horizontal {
		[code-point, recipe] [`U+${hex-value}`, [dm h${i}]]
		symbol-data [character, designation]=[\u{format("{:04X(0x1F031)}", ${i})}, "00-0${i}"]
	}
}
generate (0x4E3 .. -10) as local let code-point {
	yield unicode-${code-point} {
		char \u{${code-point}}
	}
}
spread ['one', 'two', 'three', 'four', 'five'] as name {
	yield digit-${name} {
		number-value: index
	}
}
spread ['aries', 'taurus', 'gemini', 'cancer', 'leo', 'virgo', 'libra', 'scorpio', 'sagittarius', 'capricorn', 'aquarius', 'pisces', 'ophiuchus'] as let name {
	local code-point = format("{:04X}", 0x2648 + index)
	yield astrological-zodiacal-sign-{name}-text {
		code-point: `U+${code-point}`
		sequence: [code-point, `FE0E`]
		pos: index
	}
}
spread (['c', 's'], ['prosgegrammeni', 'ypogegrammeni']) as let (letter-case, suffix) {
	local const code-points = [1FBC, 1FB3]
	yield hel_${letter-case}_let_a_alpha__${suffix} {
		unicode: select(code-points)
		symbol {
			letter: hel_${letter-case}_let_a_alpha
		}
	}
}

const data = {
	/|\ expansion-spread: zip-итерирует источники и расширяет yield-результаты в текущий контейнер
	spread (['c', 's'], ['prosgegrammeni', 'ypogegrammeni'], [1FBC, 1FB3]) as let (letter-case, suffix, code-point) {
		yield hel_${letter-case}_let_a_alpha__${suffix} {
			unicode: code-point
			symbol {
				letter: `hel_${letter-case}_let_a_alpha`
			}
		}
	}
}
const data = {}
spread (['c', 's'], ['prosgegrammeni', 'ypogegrammeni'], [1FBC, 1FB3]) as let (letter-case, suffix, code-point) {
	/|\ procedural-spread: zip-итерирует источники и выполняет тело ради побочных эффектов
	data.hel_${letter-case}_let_a_alpha__${suffix} {
		unicode: code-point
		symbol {
			letter: `hel_${letter-case}_let_a_alpha`
		}
	}
}
const merged = {};
spread({a:1, b:2}, {c:3, d:4}) as let (k, v) {
    merged[k] = v
}
const obj = {
    spread({a:1, b:2}) as let (k, v) {
        yield { [k]: v }
    }
}
const result = {};
spread({a:1, b:2}, {c:3, d:4}) as let (k, v) {
    if (v % 2 === 0) result['even_' + k] = v
}

const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]
const evenNumbers = [
	/|\ filter как expression-блок: итерирует источник, отдаёт только yield-значения в результирующий массив
  filter (numbers) as let (n) {
    if (n % 2 == 0) yield n
  },
	value(),
	value(),
	value(),
]
const evenNumbers = {
	/|\ filter как expression-блок для объектов: итерирует источник, yield отдаёт пары ключ-значение в результирующий объект
  filter (numbers) as let (n) {
    if (n % 2 == 0) yield {number_${n}: n}
  }
}

obj.method()
obj.methods()

class String extends Prototype {
	public methods = {}

	static Init() {
		const use = global.variableName
	}
}

for (index, value) in [...] {

}

for item in Array { ... }

for (k, v) in {...} { ... }
for (key, value) in {...} { ... }

loop 15 {
	if (index < 10) { ... }
}

function name(input, data) {
	
}

function name (argument<Float>, argument<Int>):<Number> { ... }

function name <T: Number, U: Number>(argument<T>: 0, argument<U>: 0):<T> { ... } /|\ Дженерики
output = name<Float, Int>(12.543, 3)

if (value is ElectricPower) { }
if (value is Base32) { }
if (value is Octal) { }
if (value is Array) { }
if (value is Table) { }
if (value is Dictionary) { }

if (typeOf(value) === 'ElectricVoltage') { }

array.spread()

function coords(x: 0, y: 0, z: 0) { }

global let flag<Boolean> true
global let index<Hex> 0x1E
loop 10 {
	global.index *= (global.index // (2 * 7))
	if (global.index > 32) {
		global.flag false
		break
	}
}

let что-то-там = 20_000μW
let speed<Speed> = unit(278, 'ft/s')
let speed<Speed> = fts(278)
let speed<Speed> = eval('278ft/s')
let speed<Speed> = 278ft/s
let time<Time> = 25μs
let length<Length> = 25pc
let degree<Degree> = 45°
const generator-power<ElectricPower> = 15kW
const vector-shield-dimension<Dimension> = 2D
const fuel-energy<Energy> = 1.5MJ
const temperature<Temperature> = +25°C
const temperature<Temperature> = 25K
const resistance<ElectricResistance> = 10_000MΩ
const resistance<ElectricResistance> = 10000kΩ
const number2<Number> = 0b1011110011
const number8<Number> = 0o071
const number16<Number> = 0x348FABD1
const number32<Number> = 0tL1FF
const number32<Number> = 0cZYX

const abcdefg = Infinitykg
const hijklmn = -Infinitykg
const abcdefg = 10kg
const hijklmn = -10kg
const hijklmn = NaN

let output [] auto none



/|\ Ключевые слова, которые не определены на уровне синтаксиса (могут быть свободно исопльзованы), но определены в подсветке синтаксиса
index index i j
value values val vals v
key keys k
item items
argument arguments arg args
each
data
flag flags f
output outputs
input inputs
x y z
t c r n m

/*
|*



*|
*/