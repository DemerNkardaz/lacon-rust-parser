[Mode:Data][Document:Dictionary]

iterator operators(operatorsArray<Array<Operator>> [+, -, *, **, /, //]):<Operator> {
	const items<Array<Operator>> operatorsArray
	return iterate(items, array)
}

function stagedMath(numbers<Array> [], operatorSymbol<Operator> +):<Number> {
	const result numbers[1] operatorSymbol numbers[2]
	return result
}

const opsIter = operators()
const bindedMath stagedMath.bind([1, 7], opsIter)


maths {
	"1 + 7" bindedMath()   /|\ 1 + 7 = 8
	"1 - 7" bindedMath()   /|\ 1 - 7 = -6
	"1 * 7" bindedMath()   /|\ 1 * 7 = 7
	"1 ** 7" bindedMath()  /|\ 1 ** 7 = 1
	"1 / 7" bindedMath()   /|\ 1 / 7 ≈ 0.142857
	"1 // 7" bindedMath()  /|\ 1 // 7 = 0  (целочисленное деление)
}

print(maths["1 + 7"])   /|\ 8
print(maths["1 - 7"])   /|\ -6
print(maths["1 * 7"])   /|\ 7
print(maths["1 ** 7"])  /|\ 1
print(maths["1 / 7"])   /|\ ≈0.142857
print(maths["1 // 7"])  /|\ 0

generate (0 .. 7) as local let i {
	local const hex-value = format("{:04X}", $i)
	yield {domino_n_tile_00_0${i}_horizontal: {
		[code-point, recipe] [`U+${hex-value}`, [dm h${i}]]
		symbol-data [character, designation]=[\u{format("{:04X(0x1F031)}", ${i})}, "00-0${i}"]
	}}
}
generate (0x4E3 .. -10) as local let code-point {
	yield {unicode-${code-point}: {
		char \u{${code-point}}
	}}
}
spread ['one', 'two', 'three', 'four', 'five'] as name {
	yield {digit-${name}: { number-value: index }}
}
spread ['aries', 'taurus', 'gemini', 'cancer', 'leo', 'virgo', 'libra', 'scorpio', 'sagittarius', 'capricorn', 'aquarius', 'pisces', 'ophiuchus'] as let name {
	local code-point = format("{:04X}", 0x2648 + index)
	yield {astrological-zodiacal-sign-{name}-text: {
		code-point: `U+${code-point}`
		sequence: [code-point, `FE0E`]
		pos: index
	}}
}
spread (['c', 's'], ['prosgegrammeni', 'ypogegrammeni']) as let (letter-case, suffix) {
	local const code-points = [1FBC, 1FB3]
	yield {hel_${letter-case}_let_a_alpha__${suffix}: {
		unicode: select(code-points)
		symbol {
			letter: hel_${letter-case}_let_a_alpha
		}
	}}
}

const data = {
	/|\ expansion-spread: итерирует источники и расширяет yield-результаты в текущий контейнер
	spread (["c", "s"], ["prosgegrammeni", "ypogegrammeni"], ["1FBC", "1FB3"]) as let (letter-case, suffix, code-point) {
		yield hel_${letter-case}_let_a_alpha__${suffix}, {
			unicode: code-point
			symbol {
				letter: 'hel_${letter-case}_let_a_alpha'
			}
		}
	}
}
const data = {}
spread (["c", "s"], ["prosgegrammeni", "ypogegrammeni"], ["1FBC", "1FB3"]) as let (letter-case, suffix, code-point) {
	/|\ procedural-spread: итерирует источники и выполняет тело ради побочных эффектов
	data.hel_${letter-case}_let_a_alpha__${suffix} {
		unicode: code-point
		symbol {
			letter: `hel_${letter-case}_let_a_alpha`
		}
	}
}
const merged = {};
spread({a:1, b:2}, {c:3, d:4}) as let (k, v) {
    merged[k] = v
}
const obj = {
    spread({a:1, b:2}) as let (k, v) {
        yield [k], v
    }
}
const result = {};
spread({a:1, b:2}, {c:3, d:4}) as let (k, v) {
    if (v % 2 === 0) result['even_' + k] = v
}

const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]
const evenNumbers = [
	/|\ filter как expression-блок: итерирует источник, отдаёт только yield-значения в результирующий массив
  filter (numbers) as let (n) {
    if (n % 2 == 0) yield n
  },
	value(),
	value(),
	value(),
]
const evenNumbers = {
	/|\ filter как expression-блок для объектов: итерирует источник, yield отдаёт пары ключ-значение в результирующий объект
  filter (numbers) as let (n) {
    if (n % 2 == 0) yield {number_${n}: n}
  }
}

obj.method()
obj.methods()

class String extends Prototype {
	public methods = {}

	static Init() {
		const use = global.variableName
	}
}

for (index, value) in [...] {

}

for item in Array { ... }

for (k, v) in {...} { ... }
for (key, value) in {...} { ... }

loop 15 {
	if (index < 10) { ... }
}

async function name(input, data) {

}

Type Unit::WaveLength Extends Unit::Length {
	private const fieldName<Number> = 0

}

function name (argument<Float>, argument<Int>):<Number> { ... }

function name <T: Number, U: Number>(argument<T>: 0, argument<U>: 0):<T> { ... } /|\ Дженерики
output = name<Float, Int>(12.543, 3)

arr<String[]> = [] /|\ С добавлением объекта (массив, словарь) мы указываем, что значение не строка, а массив/словарь строк
arr<String[][]> = [] /|\ Массив массивов строк
arr<String{}> = {}
arr<String[]{}> = {} /|\ Словарь, где значения — массивы строк

function name <T: Any[], U: Any{}>(argument<T>, argument<U>):<Any> { ... } /|\ Объекты аргументов могут содержать любой тип данных, но сами аргументы могут быть только массивом и словарём
output = name<ElectricPower, ElectricCapacitance>(Array, Dictionary) /|\ Несмотря на объявление типов без [], {} — аргументы всё равно могут быть только массивом и словарём, как было при объявлении функции

if (value is ElectricPower) { }
if (value is Base32) { }
if (value is Octal) { }
if (value is Array) { }
if (value is Table) { }
if (value is Dictionary) { }

if (typeOf(value) === 'ElectricVoltage') { }

array.spread()

function coords(x: 0, y: 0, z: 0) { }
function name(x, argument? /* Опциональный аргумент */) {
	if !(argument is Nil) {}
	if !(argument === nil) {}
	if (argument !== nil) {}
	if (typeOf(argument) !== 'nil') {}
}
function name(x, argument<Int>? /* Опциональный аргумент */) {}
function name(x, &argument<Int>? /* Опциональный refrence-аргумент */) {}


strict function name(a, b) { ... } /|\ Строгая функция, не может влиять на данные вне своего scope, мутировать входные данные

function name(a, b) { global.c = a + b } /|\ OK
strict function name(a, b) { global.c = a + b } /|\ Ошибка

global let flag<Boolean> true
global let index<Hex> 0x1E
loop 10 {
	global.index *= (global.index // (2 * 7))
	if (global.index > 32) {
		global.flag false
		break
	}
}
const name = new Class()

const baseSymbol<Dictionary> {
	unicode<String>: ""
}

const data = {
	spread(['c', 's'], ['prosgegrammeni', 'ypogegrammeni'], ['1FBC', '1FB3']) as let (letter-case, suffix, code-point) {
		const base = with baseSymbol { unicode: code-point }
		yield { hel_${letter-case}_let_a_alpha__${suffix}: base }
	}
	/|\ ↓
	hel_c_let_a_alpha__prosgegrammeni {
		unicode: '1FBC'
	}
	hel_s_let_a_alpha__ypogegrammeni {
		unicode: '1FB3'
	}
}

structure TestObject {
	x<Length>: 15cm
	y<Length>: 15cm
	z<Length> => root.x * root.y /|\ key => value — «ленивый доступ», вычисляет значение каждый раз при доступе к нему
}

const newObject<TestObject> {x: 30cm}
print(newObject.z) /|\ = 450cm

const obj  {
	key: 1
	obj { obj { obj { obj { obj { obj { obj { key: root.key } } } } } } } /|\ root — корент текущего объявленного объекта-значения
	key2: root.obj.obj.obj.obj.obj.obj.obj
}

class SomeClass {
	public static version = 1
	public version = 1

	Init(version) {
		/|\ «origin» позволяет ссылаться на исходный объект (например, инстансу класса на сам класс, вместо того, чтоб прописывать его имя)
		if (this.version > origin.version) {
			...
		}
	}
}
/|\ придумать как ссылаться на свойства верхнего класса (когда class classname extends classname)

const arr = new Array() === const arr = []

archive.get("data")

let что-то-там = 20_000μW
let speed<Velocity> = unit(278, nft/s)
let speed<Velocity> = fts(278)
let speed<Velocity> = eval('278ft/s')
let speed<Velocity> = 278ft/s
let time<Time> = 25μs
let length<Length> = 25pc
let degree<Degree> = 45°
const generator-power<ElectricPower> = 15kW
const vector-shield-dimension<Dimension> = 2D
const fuel-energy<Energy> = 1.5MJ
const temperature<Temperature> = +25°C
const temperature<Temperature> = 25K
const resistance<ElectricResistance> = 10_000MΩ
const resistance<ElectricResistance> = 10000kΩ
const field-area<Area> = 73.14m2
const cube-volume<Volume> = 15m3
const vessel-volume<Volume> = 0.1kL /|\ 0.1 килолитра
const number2<Number> = 0b1011110011
const number8<Number> = 0o071
const number16<Number> = 0x348FABD1
const number32<Number> = 0tL1FF
const number32<Number> = 0cZYX
const mib<BitRate> = 25MiByte/s
const mib<BitRate> = 25kbit/s
let a<Velocity> = 2.5m/s
let a<Acceleration> = 2.5m/s2
let a<Jerk> = 2.5m/s3
let a<Snap> = 2.5m/s4
let a<Crackle> = 2.5m/s5
let a<Pop> = 2.5m/s6
let a<Velocity> = 2.5Tm/h
let a<Velocity> = 2.5km/h
let a<Velocity> = 2.5m/h
let a<Velocity> = 2.5μm/s

let a<Illuminance> = 25lx
let a<LuminousFlux> = 25lm
let a<LuminousIntensity> = 25cd
let a<Amount> = 25mol

let a<Momentum> = 25kg*m/s
let a<Momentum> = 25kg⋅m/s
let a<Momentum> = 25kg/ms
let a<Momentum> = 25kg/μs
let a = 10kW⋅s
let a = n kW⋅s
let conv = 25m3 -> nL /|\ = 25.000 Литров
let conv = 25m3 → nL /|\ = 25.000 Литров

const converter(inputVolume<Volume>: 1000L, outputVolume<Volume>: nkL):<Volume> {
	return inputVolume -> outputVolume /|\ = 1kL (Килолитр)
}

public function name(...):<Int> {
	{ /|\ Просто вложенный блок
	}

	§ { /|\ Анонимная секция
	}

	static §section-name { /|\ Именованная секция
		const name<Int> = ...

		strict public function name(...):<Int> { ... }
	}

	§section-name-2 {
		const name<Int> = §section-name.name ×× 4
	}

	return §section-name.name(§section-name2.name)
}

/|\ К статическим секциям и их полям внутри функции можно получить доступ извне, и это единственные данные, которые можно получить таким образом без вызова функции:

public function calculate_tax(amount:<Float>):<Float> {
  static §config {
    public const rate<Float> = 0.20 /|\ По умолчанию public, не обязательно явно указывать
    public const limit<Int> = 1000
    private const что-то-ещё<Int> = 1 /|\ К этому полю нельзя будет получить доступ извне
  }

  return amount * §config.rate
}

print(calculate_tax.§config.rate)

public function renderButton(settings<Dictionary> = self.§settings.UI) { /|\ self — интроспективный указатель контекста, в отличие от this, позволяет ссылаться на внутренние свойства вызываемой функции
	static §settings {
		public const UI<Dictionary> = {
			width<Length>: 15em,
			height<Length>: 2.5em,
			font-size<Length>: 1.25rem,
			border-radius<Length>: 5px,
			color<Color>: RGBA(250, 130, 70, 1),
		}
	}

	§sub-functions { ... }

	const buttonObject = ...

	/* buttonObject handling */

	return buttonObject
}

const myButtonElement = renderButton({...self.§settings.UI, color: RGBA(200, 200, 120, 0.8)})

§utils {
	public strict function isOdd(input<Int>):<Boolean> => input % 2 !== 0
	public strict function isEvent(input<Int>):<Boolean> => input % 2 === 0
	public strict function truncate(input<String>, length<Int>, ending<String> = '...'):<String> => input.subStr(1, length) ending

	public procedure switchLanguage(language<String> = "en-US") {
		try {
			if language in LanguageClass.supportedList {
				LanguageClass.currentLanguage = language
			}
		} catch as e {
			throw e
		}
	}

	public procedure switchLanguage(language<String> = "en-US") {
		try
			if language in LanguageClass.supportedList
				LanguageClass.currentLanguage = language
		catch as e
			throw e
	}

	public procedure switchLanguage(language<String> = "en-US") {
		try { language in LanguageClass.supportedList && LanguageClass.currentLanguage = language }
		catch as e { throw e }
	}
}

const expressions = {
	flux_by_time_3<Expr> = <LuminousFlux> / <Time ** 3>
}

const createExpressionAlias {
	exprAlias<Expr> = expressions.flux_by_time_3
}

const usingExpressionFromAlias = createExpressionAlias.exprAlias(40lm / 3sec)

/|\ Больше применимо для схем:

const mySchema = {
	expr<Expr>: <LuminousFlux> / <Time ** 3>
}
const useSchema = use schema mySchema {
	expr = 40lm / 3sec /|\ ≈1.481 lm/s³
}
const useSchema = use schema mySchema {
	expr = 40lx / 5g /|\ Ошибка, типы противоречат объявленному выражению
}


const volume = converter(2700L) /|\ = 2.7kL (Килолитров)
const volume = converter(2700L, 0ML) /|\ = 0.0027ML (Мегалитров)
const volume = 25m3 + 3000L /|\ = 28m3 (Используется тип операнда слева)
const volume = 25m3 + 10 /|\ = 35m3 (Числа без типов Unit приравниваются к типу операнда слева)

const abcdefg = Infinitykg
const hijklmn = -Infinitykg
const abcdefg = 10kg
const hijklmn = -10kg
const hijklmn = NaN

global let power_list<ElectricPower[]> = [10kW, 15kW, 20kW]
global let caps_map<ElectricCapacitance{}> = { main: 100μF, extra: 10μF }

let output = []

const monus = 25kW ∸ 100
const monus = 25 .- 100
const (a, b) = ([20kW, 50kW], [10MJ, 8MJ])
const cartesian = a ∔ b
			cartesian ≣ [(20kW, 10MJ), (20kW, 10MJ), (50kW, 10MJ), (50kW, 10MJ)]

.= != &= += -= /= %=
== === <= => !=
=> |> ->
25 ∸ 100
string ≣ string

const floot = ⌊ 29.3kW ⌋
const ceil = ⌈ +17.1°C + Δ +14°F ⌉
const ev = 17MeV + (1000ppt * 500%)
100‱

delete(user) {
    sanction unauthorized => deny
}

sanction overflow => panic
sanction access_violation => log

const entity = new User {
    role be only admin | guest
    password may exist

    action delete() {
        only admin
        condition authenticated
        sanction unauthorized -> deny
		} {
			/* Логика */
		}
}
/|\ Статус экшена:
allowed
denied
sanctioned
executed

policy AdminOnly {
    only admin
    sanction unauthorized -> deny
}
const user<Subject> {

}

action deleteUser() {
    use AdminOnly
    condition authenticated
} {
    eraseUser()
}



/|\ Ключевые слова, которые не определены на уровне синтаксиса (могут быть свободно исопльзованы), но определены в подсветке синтаксиса
index index i j
value values val vals v
key keys k
item items element elements elem elems
argument arguments arg args
each
data
flag flags f
output outputs
input inputs
x y z
t c r m n

get set

/*
|*



*|
*/



/|\ Типы

String
Boolean
Color
Number > Int | Float | Binary | Octal | Hex | Base32
Object > Array | Dictionary | Subject | Table | Function | MultilineString
Auto | None | Nil | Undefined
Unit >
	| Degree
	| Radian
	| Percent
	| Length
	| Time
	| Frequency
	| Velocity
	| Acceleration
	| Snap
	| Crackle
	| Pop
	| Size
	| BitRate
	| Mass
	| Fraction
	| Dimension
	| Temperature
	| ElectricVoltage
	| ElectricCurrent
	| ElectricCharge
	| ElectricResistance
	| ElectricConductance
	| ElectricCapacitance
	| ElectricPower
	| Illuminance
	| LuminousFlux
	| LuminousIntensity
	| Amount
	| Pressure
	| Energy
	| Force
	| Area
	| Volume


/|\ Маркер указывает на то, что всё что идёт после него — объект данных. Это позволяет использовать язык как динамическое хранилище данных без лишних сложностей с выводом нужного для чтения программой
[Marker:Output<Dictionary>]
key<Boolean> value
key {
	key<String> ${if (condition) {} else {}}
	key<String> ${condition ? then : else}
	key<Int> value
	key<String> 'Это строка со ссылкой на ${переменную} ${LuminousFlux} ${if ...}'
}
key<Array> [
	item
	item
	item
	item
]
[Marker:Output<Dictionary> as JSON]
[Marker:Output<Dictionary> as YAML]
